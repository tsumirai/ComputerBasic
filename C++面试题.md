1. 引用和指针有什么区别  
* 定义一个指针变量，编译器会为它分配内存，而引用不占用任何内存；
* 引用必须在定义时被初始化，指针不必；
* 不存在指向空值的引用，但存在指向空值的指针  
2. 函数参数传递中值传递、地址传递、引用传递有什么区别
* 值传递：会为形参重新分配内存空间，将实参的值拷贝给形参，形参的值不会影响实参的值，函数调用结束后，形参被释放；
* 引用传递：不会为形参重新分配空间，形参只是实参的别名，形参的改变会影响实参的值，函数调用结束后，形参不会被释放；
* 地址传递：形参为指针变量，将实参的地址传递给函数，可以在函数中改变实参的值，调用时为形参指针变量分配内存，结束时释放指针变量。
3. static关键字有什么作用
* 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时维持上次的值；
* 在模块内的static全局变量可以被模块内所有函数调用，但不能被模块外其他函数访问；
* 在模块内的static函数只能被这一模块内的其他函数调用，这个函数的适用范围被限制在声明它的模块内；
* 在类中的static成员变量属于整个类拥有，对类的对象只有一份拷贝；
* 在类中的static成员函数属于整个类拥有，这个函数不接受this指针，因而只能方访问static成员变量。
4. const关键字有什么作用？
* 阻止一个变量被改变，可以使用const关键字。在定义该const变量时，通常需要对它初始化，因为以后就没有机会改变它了；
* 对指针来说，可以指定指针本身为const，也可以指定指针所指的数据为const，或者二者同时指定为const；
* 在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值；
* 对于类的成员函数，若指定其为const类型，则表明其是一个常函数，不能修改类的成员变量；
* 对于类的成员函数，有时候必须指定其返回值为const类型，以使得其返回值不为左值。
5. 链表和数组的区别在哪里？
* 链表和数组都可以叫线性表，数组又叫顺序表，主要区别在于，顺序表是在内存中开辟一段连续的空间来存储数据，而链表是靠指针来连接多块不连续的空间，在逻辑上行程一片连续的空间来存储数据；
* 数组要求空间连续，占用总空间小，链表不要求空间连续，占用总空间大；
* 数组方便排序和查找，但删除和插入较慢；链表方便删除和插入，但查找较慢，不方便排序。
6. 请编写能直接实现strlen()函数功能的代码
``` C++
int strlen(char *str) {
    int i = 0;
    for (;str[i] != '\0'; i++);
    return i;
}
```
7. 请编写能直接实现strstr()函数功能的代码
```C++
char *strstr(const char *str, const char *sub) {
    if (NULL == str1 || NULL == str2) {
        return NULL;
    }
    char *dest = (char *)str1;
    char *src = (char *)str2;
    char *flag = NULL;
    while(*dest) {
        flag = dest;
        src = (char *)str2;
        while(*flag && *src && (*flag == *src)) {
            flag++;
            src++;
        }
        if (!*src) {
            return dest;
        } else {
            dest++;
        }
    }
}
```
8. 进程和线程的差别  
线程是进程内的一个执行单元，也是进程内的可调度实体。进程和线程的区别：
* 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位
* 并发性：不仅进程之间可以并发执行，同一个进程的多个线程也可以并发执行
* 拥有资源：进程是拥有资源的一个独立单元，线程不拥有系统资源，但可以访问隶属于进程的资源
* 系统开销：在创建或撤销进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤销线程时的开销。  
9. const char* const p 是什么意思
* char* const p  常量指针，p的地址不可修改
* char const *p  指向常量的指针，指向的内容不可修改
* const char *p  同char const *p
* const char * const p  内容和地址都不可以改变
10. memset、memcpy和strcpy的根本区别
* memset用来对一段内存空间内全部设置为某个字符，一般用在对定义的字符串进行初始化为指定值
* memcpy用来做内存拷贝，可以用来拷贝任何数据类型的对象，可以指定拷贝的数据长度
* strcpy只能拷贝字符串，遇到'\0'就结束拷贝
11. 析构函数有哪些特点
* 析构函数也是特殊的类成员函数，它没有返回类型
* 没有参数
* 没有重载
* public、private、protected等权限控制对析构函数无效
* 析构函数不能手动调用，只是在类对象生命周期结束的时候，由系统自动调用释放在构造函数中分配的资源
12. 虚函数有什么作用
* 虚函数的功能是使子类可以用同名的函数对父类函数进行覆盖，并且在通过父类指针调用时，如果有覆盖则自动调用子类覆盖函数，如果没有覆盖则调用父类中的函数，从而实现灵活扩展和多态性
* 如果是纯虚函数，则纯粹是为了在子类覆盖时有一个统一的命名而已，子类必须覆盖纯虚函数，否则子类也是抽象类
* 含有纯虚函数的类称为抽象类，不能实例化对象，主要用作接口类
13. 虚析构函数有什么作用
* 析构函数的工作方式是：最底层的派生类的析构函数最先被调用，然后调用每一个基类的析构函数
* 在C++中，当一个派生类对象通过使用一个基类指针删除，而这个基类有一个非虚的析构函数，则可能导致运行时派生类不能被销毁。然而基类部分很有可能已经被销毁，这就导致“部分析构”现象，造成内存泄露
* 给基类一个纯析构函数，删除一个派生类对象的时候就将销毁整个对象，包括父类和全部派生类部分
14. 分别给出bool、int、float、指针变量与零值比较的if语句
* bool型变量  if(!var)
* int型变量   if(var == 0)
* float型变量   const float EPSINON = 0.000001;  
                if ((x >= -EPSINON) && (x <= EPSINON))
* 指针变量  if (var == NULL)
15. 深度遍历二叉树
* 深度优先搜索算法：沿着树的深度遍历树的节点，尽可能深地搜索树的分支
* 广度优先搜索算法：又叫宽度优先搜索，或者横向优先搜索，是从根节点开始，沿着树的宽度遍历树的节点，如果所有节点均被访问，则算法停止。
16. C++中的inline内联函数与普通函数的区别
* 所谓“内联函数”就是将很简单的函数内嵌到调用它的程序代码中，这样做的目的是节约原本函数调用时的时空开销，但作为内联函数，函数体必须十分简单，不能含有循环、条件、选择等复杂的结构
* 内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候内联函数会像宏一样展开，所以取消了函数的参数压栈，减少了调用的开销。可以像调用函数一样调用内联函数，而不必担心会产生处理宏的一些问题
* 可以用inline来敌营内联函数，不过，任何在类的说明部分定义的函数都会被自动的认为是内联函数。内联函数必须是和函数体声明在一起才有效。
17. C++重写、重载、重定义的区别
* 成员函数重载的特征   
  * 相同的范围，在同一个类
  * 函数名字相同
  * 参数不同
* 重写（覆盖）是指派生类函数覆盖基类函数，特征是
  * 不同的范围，分别位于基类和派生类中
  * 函数的名字相同
  * 参数相同
  * 基类函数必须有virtual关键字
* 重定义（隐藏）是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
  * 如果派生类的函数和基类的函数同名，但是参数不同，此时不管有无virtual，基类的函数被隐藏
  * 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字，此时基类函数被隐藏
18. 一个数据成员是否可以既是const又是static，如果不行，为什么
* 一个数据成员可以既是const又是static，表示为静态常量
* 常量一般在构造函数后初始化
* 静态成员一般在类外初始化
* 静态常量在类外初始化，但要在类外初始化的同时声明为const
19. 构造函数与析构函数的异同点
* 构造函数有以下特点：
  * 构造函数的名字必须与类名相同
  * 构造函数可以有任意类型的参数，但不能有返回类型
  * 定义对象时，编译系统会自动调用构造函数
  * 构造函数是特殊的成员函数，函数体可以再类体内也可以在类体外
  * 构造函数被声明为公有函数，但它不能像其他成员函数那样被显式调用，它是在定义对象的同时被调用的
* 析构函数有如下特点：
  * 析构函数的名字必须与类名相同，但它前面必须加一个波浪号
  * 析构函数没有参数，也没有返回值，而且不能被重载，因此在一个类中只能有一个析构函数
  * 当撤销对象时，编译系统会自动调用析构函数
  * 析构函数可以是virtual，而构造函数不能是虚函数
20. 自动调用复制构造函数的几种情形
* 复制构造函数的功能是用一个已知对象来初始化另一个同类的对象。复制构造函数其实也是类的构造函数，与类名相同，有且只有一个参数，是该类对象的引用；每个类必须有一个复制构造函数。如果定义类的时候没有编写，编译器编译时会自动生成一个复制构造函数
* 复制构造函数在以下三种情况下会被自动调用
  * 当类的一个对象去初始化该类的另一个对象时
  * 如果函数的形参是类的对象，调用函数进行形参和实参结合时
  * 如果函数的返回值是类对象，函数调用完成返回时
21. 类型转换构造函数是什么？举个例子    
类型转换构造函数就时自动调用类型匹配的构造函数，自动将基本数据类型转换成对象。例子如下：
``` C++
#include<iostream>
using namespace std;
class Person{
    public:
        double height;
        Person(double h) {height = h;}
};
void main() {
    Person yaoming = 2.3;
    count << yaoming.height<<endl;
}
```  
22.  简述C++异常处理方式  
一个典型的C++异常处理包括以下几个步骤：
* 程序执行时发生错误
* 以一个异常对象（最简单是一个整数）记录错误的原因及相关信息
* 程序检测到这个错误（读取异常对象）
* 程序决定如何处理错误
* 进行错误处理，并在此后恢复/终止程序的执行
23. 成员函数和友元函数的区别
* 成员函数是类定义的一部分，通过特定的对象来调用。成员函数既可以隐式访问调用对象的成员，而无需使用成员操作符
* 友元函数不是类的组成部分，因此被称为直接函数调用。友元函数不能隐式访问类成员，而必须将成员操作符用于作为参数传递的对象
24. C++中哪些运算符不可以重载
不能重载的5个运算符
* .
* ?:
* sizeof
* ::
* \*
25. 如何重载前++和后++运算符
前++不带参数，后++带一个int型参数以示区分
``` C++
iCount &operator ++() //前缀++
{
    count <<"前缀++"<<endl;
    m_data++;
    return *this;
}
```  
``` C++
iCount &operator ++(int) //后缀++
{
    count <<"后缀++"<<endl;
    iCount temp = *this;
    m_data++;
    return temp;
}
```  
26. 请说出STL标准模板库中的几个常用类  

数据结构 | 描述 | 实现头文件  
:-: | :-: | :-:  
向量（vector） | 连续存储的元素 | \<vector>    
列表（list） | 由节点组成的双向链表 | \<list>  
集合（set） | 由节点组成的集合 | \<set>  
栈（stack） | 后进先出的值的排列 | \<stack>  
队列（queue） | 先进先出的值的排列 | \<queue>  
映射（map） | 由键值对组成的集合 | \<map>  
27. 函数模板与函数重载的异同
* 函数的重载是指定义了几个名字相同，但参数的类型或参数的个数不同的函数
* 模板函数是指几个函数的具体算法相同，但参数类型不同的函数
* 模板函数可以减少重载函数，但也可能引发错误。
28. 类型转换构造函数是什么
类型转换构造函数就是自动调用类型匹配的构造函数，自动将基本数据类型转换成对象
29. C++中explicit关键字有什么作用
explicit和构造函数一起使用，explicit指明构造函数只能显式使用，目的是为了防止不必要的隐试调用类型转换构造函数
```C++
#include<iostream>
using namespace std;
class Person {
    int height;
    public: 
        Person(){}
        explicit Person(int h) //explicit修饰构造函数
        {
            height = h;
        }
        void display() {
            count <<height << endl;
        }
};

void main() {
    //Person yaoming = 2.3; //构造函数用explicit修饰后将不能隐式调用类型转换构造函数
    Person yaoming(2.3); //可以显式调用类型构造函数
}
```  
30. C++中restrict关键字有什么作用  
* restrict是用来优化的
* restrict只能修饰指针，restrict修饰的指针是能够访问所指区域的唯一入口，限制多个指针指向同一地址
31. 编写一个单例模式的例子  
```C++
#include<iostream>
using namespace std;
class CSingleton {
    private:
        CSingleton{}//构造函数私有
        static CSingleton *m_pInstance;
    public:
        static CSingleton *GetInstance() {
            if (m_pInstance == NULL) //判断是否是第一次调用
            {
                m_pInstance = new CSingleton();
                return m_pInstance;
            }
        }
};
CSingleton *CSingleton::m_pInstance = NULL; //static属性类外初始化
void main() {
    CSingleton *p1 = CSingleton::GetInstance();
    CSingleton *p2 = CSingleton::GetInstance();
    cout <<(p1 == p2) << endl; //结果为true表示单例
}
```  
32. 面向对象的三大特征是什么  
面向对象的三个基本特征：封装、继承、多态
33. 什么是封装
* 封装是面向对象的特征之一，是对象和类概念的主要特性
* 封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏
* 在C++中类中成员的属性有：public、protected、private，这三个属性的访问权限依次降低
34. 什么是继承
* 继承是指：可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展
* 通过继承创建的类被称为“子类”或“派生类”
* 被继承的类被称为“基类”、“父类”或“超类”
* 在某些OOP语言中，一个子类可以继承多个基类，但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现
* C++中可以用public、protected、private来修饰继承特性
35. 什么是多态
* 多态性：允许将父类对象设置为和一个或更多的它的子对象相等的技术，赋值之后，父对象可以根据当前赋值给它的子对象的特性以不同的方式运作。简单地说，允许将子类类型的指针赋值给父类型的指针
* 实现多态的两种方式：覆盖、重载
* 覆盖：子类重新定义父类的虚函数
* 重载：允许存在多个同名函数，而这些函数的参数表不同
36. 类与对象的区别？  
类域对象的区别，它们是一般与个体、抽象与具体、集体与个体的区别
36. C++中namespace是什么  
namespace是命名空间，是C++的语言特性，类似于java中的包
37. 什么是可重入和不可重入函数
* 什么是可重入性  
可重入函数可以由多个任务并发使用，而不必担心数据错误。相反，不可重入函数不能由多个任务共享，除非能确保函数的互斥。可重入函数可以再任意时刻被中断，稍后继续运行，不会丢失数据，可重入函数要么使用本地变量，要么使用全局变量来保护自己的数据
* 可重入函数  
不可连续的调用持有静态数据  
不返回指向静态数据的指针，所有数据都是由函数的调用者提供  
使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据  
如果必须访问全局变量，记住使用互斥信号量来保护全局变量  
绝不调用任何不可重入函数  
* 不可重入函数  
函数中使用了静态变量，无论是全局静态变量还是局部静态变量  
函数返回静态变量  
函数中调用了不可重入函数  
函数体内使用了静态的数据结构  
函数体内调用了malloc()或者free()函数  
函数体内调用了其他标准I/O函数  
总之，如果一个函数在重入条件下使用了未受保护的共享资源，那么就是不可重入的
39. vector的reserve和capacity的区别？  
reserve()用于让容器预留空间，避免再次分配内存；capacity()返回在重新进行分配以前所能容纳的元素数量
40. 如何初始化const和static数据成员  
通常在类外申明static成员，但是static const的整型（bool,char,int,long）可以在类中声明且初始化，static const其他类型必须在类外初始化（包括整型数组）
41. static和const分别怎么用，类里面static和const可以同时修饰成员函数吗  
static的作用  
* 对变量  
    * 局部变量：  
    在局部变量之前加上关键字static，局部变量就被定义为一个局部静态变量
    1. 内存中的位置：静态存储区
    2. 初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非它被显式初始化）
    3. 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域也随之结束  
    注：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置（从原来的栈中存放改为静态存储区）及其生命周期（局部静态变量在离开作用域后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对它进行访问），但未改变其作用域  
    * 全局变量：  
    在全局变量之前加上关键字static，全局变量就被定义为一个全局静态变量
    1. 内存中的位置：静态存储区（静态存储区在整个程序运行期间都存在）
    2. 初始化：未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非它被显式初始化）
    3. 作用域：全局静态变量在声明它的文件之外是不可见的。准确地讲从定义之处开始到文件结尾  
    注：static修饰全局变量，并未改变其存储位置及生命周期，而是改变了其作用域，使当前文件外的源文件无法访问该变量，好处如下：（1）不会被其他文件所访问、修改（2）其他文件中可以使用相同名字的变量，不会发生冲突。**对全局函数也是有隐藏作用**。而普通全局变量只要定义了，任何地方都能使用，使用前需要声明所有.c文件，只能定义一次普通全局变量，但是可以声明多次（外部链接）。注意：全局变量的作用域是全局范围，但是在某个文件中使用时，必须先声明。
* 对类中的
    * 成员变量  
    用static修饰类的数据成员实际使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象。因此，static成员必须在类外进行初始化（初始化格式：int base::var = 10;），而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化。因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这是矛盾的。  
    特点：
    1. 不要试图在头文件中定义（初始化）静态数据成员。在大多数的情况下，这样做会引起重复定义这样的错误。即使加上#ifndef  #define  #endif或者#pragma once也不行
    2. 静态数据成员可以成为成员函数的可选参数，而普通数据成员则不可以。
    3. 静态数据成员的类型可以是所属类的类型，而普通数据成员则不可以。普通数据成员只能声明为所属类类型的指针或引用。
    * 成员函数
    1. 用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针
    2. 静态成员是可以独立访问的，也就是说，无需创建任何对象实例就可以访问。base::func(5,3);当static成员函数在类外定义时不需要加static修饰符
    3. 在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。因为静态成员函数不含this指针。  
**不可以同时用const和static修饰成员函数**  
C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的  
我们也可以这样理解：两者的语意是矛盾的。static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能被修改类的实例的状态，与类型的静态变量没有关系，因此不能同时用它们。
* const的作用
    1. 限定变量不可修改
    2. 限定成员函数不可以修改任何数据成员
    3. const与指针  
        const char *p 表示指向的内容不能改变
        char * const p，就是将p声明为常指针，它的地址不能改变，是固定的，但是它的内容可以改变
42. 指针和引用的区别  
本质上的区别是，指针是一个新的变量，只是这个变量存储的是另一个变量的地址，我们通过访问这个地址来修改变量。  
而引用只是一个别名，还是变量本身。对引用进行的任何操作就是对变量本身进行操作，以此达到修改变量的目的。  
    注：  
    1. 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：  
    int a = 1; int *p = &a;  
    int a = 1; int &b = a;  
    上面定义了一个整型变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址  
    而下面2句定义了一个整型变量a和这个变量的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。
    2. 可以有const指针，但是没有const引用（const引用可读不可改，与绑定对象是否为const无关）  
    注：引用可以指向常量，也可以指向变量。例如int &a = b，使引用a指向b。而为了让引用指向常量，必须使用常量引用，如const int &a = 1;它代表的是引用a指向一个const int型，这个int型的值不能被改变，而不是引用a的指向不能被改变，因为引用的指向本来就是不可变的，无需加const声明。即指针存在常量指针int const *p和指针常量int *const p，而引用只存在常量引用int const &a，不存在引用常量int & const a。  
    3. 指针可以有多级，但是引用只能是一级（int **p;合法，但是int &&a是不合法的）
    4. 指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化
    5. 指针的值在初始化后可以改变，即指向其他的存储单元，而引用在进行初始化后就不会再改变了
    6. sizeof引用得到的是所指向的变量（对象）的大小，而sizeof指针得到的是指针本身的大小
    7. 指针和引用的自增（++）运算意义不一样
    8. 指针使用时需要解引用（*），引用则不需要
43. 什么是多态，多态有什么用途  
C++多态有两种：静态多态（早绑定）、动态多态（晚绑定）。静态多态是通过函数重载实现的，动态多态是通过虚函数实现的  
* 定义：“一个接口，多种方法”，程序在运行时才决定要调用的函数
* 实现：C++多态性主要是通过虚函数实现的，虚函数允许子类重写override（注意和overload的区别，overload是重载，是允许同名函数的表现，这些函数参数列表/类型不同）。  
注：多态与非多态的实质区别就是函数地址是静态绑定还是动态绑定。如果函数的调用在编译器编译期间就可以确定函数的调用地址，并产生代码，说明地址是静态绑定的；如果函数调用的地址是需要在运行期间才确定，属于动态绑定  
* 目的：接口重用。封装可以使得代码模块化，继承可以扩展已存在的代码，他们的目的都是为了代码重用。而多态的目的则是为了接口重用。  
* 用法：声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法  
用一句话概括：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数  
```
关于重载、重写、隐藏的区别  
Overload（重载）：在C++程序中，可以将语义、功能相似的几个函数用同一个名字表示，但参数或返回值不同（包括类型、顺序不同），即函数重载  
1. 相同的范围（在同一个类中）；
2. 函数名字相同；
3. 参数不同；
4. virtual关键字可有可无  
Override（覆盖或重写）：是指派生类函数覆盖基类函数，特征是：
1. 不同的范围（分别位于派生类与基类）
2. 函数名字相同
3. 参数相同
4. 基类函数必须有virtual关键字  
注：重写基类虚函数的时候，会自动转换这个函数为virtual函数，不管有没有加virtual，因此重写的时候不加virtual也是可以的，不过为了易读性，还是加上比较好  
Overwrite（重写）：隐藏，是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
1. 如果派生类的函数与基类的函数同名，但是参数不同，此时不论有无virtual关键字，基类的函数都将被隐藏（注意别与重载混淆）
2. 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字，此时，基类的函数被隐藏（注意别与覆盖混淆）
```  
**虚函数表**  
多态是由虚函数实现的，而虚函数主要是通过虚函数表（V-Table）来实现的。  
如果一个类中包含虚函数（virtual修饰的函数）那么这个类就会包含一张虚函数表，虚函数表存储的每一项都是一个虚函数的地址。如下图：  
![1118296-20180427132656139-1777407660.jpg](1118296-20180427132656139-1777407660.jpg)  
这个类的每一个对象都会包含一个虚指针（虚指针存在于对象实例地址的最前面，保证虚函数表有最高的性能），这个虚指针指向虚函数表。  
**注：对象不包含虚函数表，只有虚指针，类才包含虚函数表，派生类会生成一个兼容基类的虚函数表**